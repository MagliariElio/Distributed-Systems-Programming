package ciociaria.annunci.it.controller;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.dao.DataAccessException;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AccountExpiredException;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.CredentialsExpiredException;
import org.springframework.security.authentication.DisabledException;
import org.springframework.security.authentication.LockedException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.web.authentication.logout.SecurityContextLogoutHandler;
import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;

import ciociaria.annunci.it.controller.dto.AmministratoreDto;
import ciociaria.annunci.it.controller.dto.RichiestaAutenticazioneDto;
import ciociaria.annunci.it.controller.dto.RichiestaRegistrazioneDto;
import ciociaria.annunci.it.controller.dto.UtenteComuneDto;
import ciociaria.annunci.it.controller.dto.mapper.RichiestaRegistrazioneDtoMapper;
import ciociaria.annunci.it.controller.dto.mapper.UtenteAmminstratoreDtoMapper;
import ciociaria.annunci.it.controller.dto.mapper.UtenteComuneDtoMapper;
import ciociaria.annunci.it.model.bean.Amministratore;
import ciociaria.annunci.it.model.bean.UtenteComune;
import ciociaria.annunci.it.service.CacheService;
import ciociaria.annunci.it.service.UtenteService;
import ciociaria.annunci.it.utils.ErrorMessages;
import ciociaria.annunci.it.utils.JwtUtils;
import ciociaria.annunci.it.utils.exceptions.DataAccessValidationException;
import io.jsonwebtoken.SignatureException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;

@RestController
@RequestMapping("/api/v1/auth")
@RequiredArgsConstructor
public class AutenticazioneController {

	private final AuthenticationManager authenticationManager;
	private final UserDetailsService userDetailsService;
	private final UtenteService utenteService;
	private final UtenteComuneDtoMapper utenteComuneMapper;
	private final UtenteAmminstratoreDtoMapper utenteAmministratoreMapper;
	private final RichiestaRegistrazioneDtoMapper richistaRegistrazioneMapper;
	
	private final JwtUtils jwtUtils;
	private final CacheService jwtCacheService;
	private static final Logger logger = LoggerFactory.getLogger(AutenticazioneController.class);

	@RequestMapping(path = "/authenticate", method = RequestMethod.POST)
	public ResponseEntity<Object> autenticazione(@Valid @RequestBody RichiestaAutenticazioneDto richiesta, BindingResult result) {
		if (result.hasErrors()) {
			List<String> errors = new ArrayList<>();
			for (FieldError field : result.getFieldErrors()) {
				errors.add(field.getDefaultMessage());
			}
			return ResponseEntity.badRequest().contentType(MediaType.APPLICATION_JSON).body(errors);
		}

		try {
			Authentication authentication = authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(
																			richiesta.getEmail(), richiesta.getPassword()));

			if (authentication != null && authentication.isAuthenticated()) {
				String token = jwtCacheService.getTokenFromCache(richiesta.getEmail());
				boolean isTokenCanBeRefreshed = jwtUtils.isTokenCanBeRefreshed(token);

				if (token != null && isTokenCanBeRefreshed == false) {
					Map<String, Object> mapResponse = loadUserInfoFromDb(token, richiesta.getEmail());
					return ResponseEntity.ok(mapResponse);
				}

				final UserDetails utente = userDetailsService.loadUserByUsername(richiesta.getEmail());

				if (utente != null) {
					if (isTokenCanBeRefreshed) {
						token = jwtUtils.refreshToken(token, utente);
						logger.info("È stato eseguito un token JWT refresh per l'utente con email '{}'.", richiesta.getEmail());
					} else {
						token = jwtUtils.generateToken(utente);
						logger.info("L'utente con email '{}' ha eseguito un nuovo accesso.", richiesta.getEmail());
					}

					jwtCacheService.storeTokenInCache(richiesta.getEmail(), token);

					Map<String, Object> mapResponse = loadUserInfoFromDb(token, richiesta.getEmail());
					return ResponseEntity.ok(mapResponse);
				}
			}
		} catch (BadCredentialsException e) {
			logger.error(ErrorMessages.ERRORE_CREDENZIALI_INSERITE + " - " + e.getMessage()
																			+ " - La email inserita è la seguente: '{}'.",
																			richiesta.getEmail());
			return ResponseEntity.status(HttpStatus.UNAUTHORIZED).contentType(MediaType.APPLICATION_JSON).contentType(MediaType.APPLICATION_JSON)
																			.body(ErrorMessages.ERRORE_CREDENZIALI_INSERITE);
		} catch (UsernameNotFoundException e) {
			logger.error(ErrorMessages.ERRORE_CREDENZIALI_INSERITE + " - La email inserita è la seguente: '{}'.",
																			richiesta.getEmail());
			return ResponseEntity.status(HttpStatus.UNAUTHORIZED).contentType(MediaType.APPLICATION_JSON).body(ErrorMessages.ERRORE_CREDENZIALI_INSERITE);
		} catch (LockedException e) {
			logger.error(ErrorMessages.ERRORE_ACCOUNT_BLOCCATO + " - " + e.getMessage()
																			+ " - La email inserita è la seguente: '{}'.",
																			richiesta.getEmail());
			return ResponseEntity.status(HttpStatus.FORBIDDEN).contentType(MediaType.APPLICATION_JSON).body(ErrorMessages.ERRORE_ACCOUNT_BLOCCATO);
		} catch (SignatureException e) {
			logger.error(ErrorMessages.ERRORE_AUTENTICAZIONE_TOKEN + " - " + e.getMessage()
																			+ " - La email inserita è la seguente: '{}'.",
																			richiesta.getEmail());
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).contentType(MediaType.APPLICATION_JSON).body(ErrorMessages.ERRORE_AUTENTICAZIONE_TOKEN);
		} catch (DisabledException e) {
			logger.error(ErrorMessages.ERRORE_ACCOUNT_DISABILITATO + " - " + e.getMessage()
																			+ " - La email inserita è la seguente: '{}'.",
																			richiesta.getEmail());
			return ResponseEntity.status(HttpStatus.UNAUTHORIZED).contentType(MediaType.APPLICATION_JSON).body(ErrorMessages.ERRORE_ACCOUNT_DISABILITATO);
		} catch (CredentialsExpiredException e) {
			logger.error(ErrorMessages.ERRORE_CREDENZIALI_SCADUTE + " - " + e.getMessage()
																			+ " - La email inserita è la seguente: '{}'.",
																			richiesta.getEmail());
			return ResponseEntity.status(HttpStatus.FORBIDDEN).contentType(MediaType.APPLICATION_JSON).body(ErrorMessages.ERRORE_CREDENZIALI_SCADUTE);
		} catch (AccountExpiredException e) {
			logger.error(ErrorMessages.ERRORE_ACCOUNT_SCADUTO + " - " + e.getMessage()
																			+ " - La email inserita è la seguente: '{}'.",
																			richiesta.getEmail());
			return ResponseEntity.status(HttpStatus.FORBIDDEN).contentType(MediaType.APPLICATION_JSON).body(ErrorMessages.ERRORE_ACCOUNT_SCADUTO);
		} catch (Exception e) {
			logger.error(e.getMessage() + " - La email inserita è la seguente: '{}'.", richiesta.getEmail());
			e.printStackTrace();
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).contentType(MediaType.APPLICATION_JSON).body(ErrorMessages.ERRORE_CREDENZIALI_GENERALE);
		}

		logger.error(ErrorMessages.ERRORE_CREDENZIALI_INSERITE + " - La email inserita è la seguente: '{}'.",
																		richiesta.getEmail());
		return ResponseEntity.status(HttpStatus.UNAUTHORIZED).contentType(MediaType.APPLICATION_JSON).body(ErrorMessages.ERRORE_CREDENZIALI_INSERITE);
	}

	private Map<String, Object> loadUserInfoFromDb(String token, String email) {
		Map<String, Object> mapResponse = new HashMap<>();	// restituirà il token e utente caricato dal DB

		UtenteComune utenteDB = utenteService.findUtenteComuneByEmail(email);
		if (utenteDB != null) {
			UtenteComuneDto utenteDto = utenteComuneMapper.apply(utenteDB);
			mapResponse.put("token", token);
			mapResponse.put("utente", utenteDto);
		} else {
			Amministratore amministratore = utenteService.findUtenteAmministratoreByEmail(email);
			AmministratoreDto amministratoreDto = utenteAmministratoreMapper.apply(amministratore);
			mapResponse.put("token", token);
			mapResponse.put("utente", amministratoreDto);
		}

		return mapResponse;
	}

	@RequestMapping(path = "/logout", method = RequestMethod.DELETE)
	public ResponseEntity<Object> logut(HttpServletRequest request, HttpServletResponse response, Authentication authentication) {
		if (authentication != null) {
			final String email = authentication.getName();
			new SecurityContextLogoutHandler().logout(request, response, authentication);
			jwtCacheService.removeTokenFromCache(email);
			logger.info("L'utente con email '{}' si è disconnesso.", email);
		}

		return ResponseEntity.ok(null);
	}

	@RequestMapping(path = "/registration", method = RequestMethod.POST)
	public ResponseEntity<Object> registrazione(@Valid @RequestBody RichiestaRegistrazioneDto richiesta, BindingResult result) {
		
		
		System.out.println(richiesta);
		
		
		if (result.hasErrors()) {
			List<String> errors = new ArrayList<>();
			for (FieldError field : result.getFieldErrors()) {
				errors.add(field.getDefaultMessage());
			}
			return ResponseEntity.badRequest().contentType(MediaType.APPLICATION_JSON).body(errors);
		}

		try {	// TODO: testing della registrazione, vedere altri TODO, modificare chi inserisce un annuncio, vedere i mapper
			UtenteComune utenteParsed = richistaRegistrazioneMapper.apply(richiesta);
			utenteService.saveUtenteComune(utenteParsed);

			final UserDetails utente = userDetailsService.loadUserByUsername(richiesta.getEmail());

			if (utente != null) {
				final String token = jwtUtils.generateToken(utente);
				logger.info("L'utente con email '{}' ha eseguito un nuovo accesso.", richiesta.getEmail());

				jwtCacheService.storeTokenInCache(richiesta.getEmail(), token);

				Map<String, Object> mapResponse = loadUserInfoFromDb(token, richiesta.getEmail());
				return ResponseEntity.ok(mapResponse);
			}
		} catch (DataAccessValidationException e) {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).contentType(MediaType.APPLICATION_JSON).body(e.getMessage());
		} catch (Exception e) {
			logger.error("{} - I dati inseriti sono i seguenti: {}", e.getMessage(), printInfoUserLog(richiesta));
			e.printStackTrace();
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).contentType(MediaType.APPLICATION_JSON).body(ErrorMessages.ERRORE_CREDENZIALI_GENERALE);
		}

		logger.error(ErrorMessages.ERRORE_REGISTRAZIONE_GENERALE + " - I dati inseriti sono i seguenti: {}.", printInfoUserLog(richiesta));
		return ResponseEntity.status(HttpStatus.UNAUTHORIZED).contentType(MediaType.APPLICATION_JSON).body(ErrorMessages.ERRORE_REGISTRAZIONE_GENERALE);
	}
	
	public String printInfoUserLog(RichiestaRegistrazioneDto richiesta) {
		return String.format("email: '%s', password: '%s' nome: '%s', cognome: '%s', username: '%s', residenza: '%s', recapitoTelefonico: '%s'", 
																		richiesta.getEmail(), 
																		richiesta.getPassword() == null ? null : "*****",
																		richiesta.getNome(), 
																		richiesta.getCognome() == null ? null : "*****",
																		richiesta.getUsername(), richiesta.getResidenza(),
																		richiesta.getRecapitoTelefonico() == null ? null : "*****").toString();
	}

}
